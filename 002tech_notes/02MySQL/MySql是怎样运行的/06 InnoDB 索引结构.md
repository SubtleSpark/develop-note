## 聚簇索引
![[Excalidraw/InnoDB存储结构.excalidraw#area=聚簇索引结构|image|2000]]


### 索引上叶节点和非叶节点比较

|                    | 非叶节点（目录）      | 叶节点（数据）     |
| ------------------ | ------------- | ----------- |
| 记录项 `record_type`  | 1             | 0           |
| 记录项 `min_rec_mask` | 每页最小项为 1      | 0           |
| 记录的列数              | 只有主键和页号，没有隐藏列 | 表的所有列，包括隐藏列 |
除了上述的几点外，两者几乎没有其他区别了。`FIL_PAGE_TYPE`都为`FIL_PAGE_INDEX`，组成结构也相同。非叶节点的主键，记录的所指向页的**最小**的主键值


### 聚簇索引特性
1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - **页内**的记录是按照主键的大小顺序排成一个**单向链表**。
    - **页与页之间**，按照主键大小顺序排成一个**双向链表**。
    - 存放目录项记录的页分为不同的层次，在**同一层次中的页**也是根据页中目录项记录的主键大小顺序排成一个双向链表。
        
2. `B+`树的叶子节点存储的是完整的用户记录。即这个记录中存储了所有列的值（包括隐藏列）。


## 二级索引
### 二级索引结构图
![[Excalidraw/InnoDB存储结构.excalidraw#area=二级索引结构|image|2000]]

- 页内的记录，按照`二级索引列 + 主键`值大小顺序排成一个单向链表。（也就是说，当索引列相等时，按主键排序）
- 同一层次的页，按照索引列的大小排序成双向链表。

### 为什么非叶节点还需要主键？
如果不包含主键，那么当几个索引列相同时，就无法知道新增的记录应该插入到哪个页里。为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除`页号`这个字段以外是唯一的。


### 聚簇索引&非聚簇索引区别

|      | 聚簇索引       | 非聚簇索引         |
| ---- | ---------- | ------------- |
| 非叶节点 | 主键 + 页号    | 索引列 + 主键 + 页号 |
| 叶节点  | 完整数据，包括隐藏列 | 索引列 + 主键      |
|      |            |               |

## 索引其他注意事项
### 根页面万年不动窝
[根页面万年不动窝](https://github.com/Relph1119/mysql-learning-notes/blob/master/docs/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B%2B%E6%A0%91%E7%B4%A2%E5%BC%95.md#%E6%A0%B9%E9%A1%B5%E9%9D%A2%E4%B8%87%E5%B9%B4%E4%B8%8D%E5%8A%A8%E7%AA%9D)


### 一个页面最少存储2条记录
[一个页面最少存储2条记录](https://github.com/Relph1119/mysql-learning-notes/blob/master/docs/mysql/06-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B%2B%E6%A0%91%E7%B4%A2%E5%BC%95.md#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%80%E5%B0%91%E5%AD%98%E5%82%A82%E6%9D%A1%E8%AE%B0%E5%BD%95)
如果可以只存储1条记录，最差的情况可能导致整个B+树无限深，使查询效率裂化


