## 基本认识
Page 是 MySQL 处理数据的基本单位
- 系统变量 innodb_page_size 设置了一个 page 的大小
- 默认 16284 即 16KB
- 只有mysql 初始化时可以修改，之后就再也不能改了

## InnoDB 行格式
### record_format_demo 数据定义
```sql
CREATE TABLE t (
    c1 VARCHAR(10),
    c2 VARCHAR(10) NOT NULL,
    c3 CHAR(10),
    c4 VARCHAR(10)
) CHARSET=ascii ROW_FORMAT=COMPACT;

/*
插入数据

+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+

*/
```

### COMPACT 行格式
####  变长字段列表
类似 `varchar(512)`、`TEXT`、`BLOB` 这种变长类型。对应的字段存储的字节数是不固定的。存储时，需要将这些字段占用的字节数也存起来。COMOACT 行格式中，各变长字段的字节数存储在头部，形成一个变长字段长度列表，并且按照列的顺序**逆序存放**。

##### 什么时候需要记
- 当一个字段是 `NULL` 时，不需要存储长度。例如第二条记录中的 c4 字段，虽是变长，但由于是`NULL` 则不会记录它的长度。
- 如果使用的字符集本身就是变长的字符集（例如UTF8），那么即使类型为 `VARCHAR(10)` 它也需要记录在 `变长字段长度列表`中。
- 如果一个需要记录变长的字段都没有（例如全是 char 类型，或所有字段都是 null），那么变长字段列表也不会存在。

##### 记录的数值是多少
每个长度的存储格式类似 [packed_integer](https://dev.mysql.com/doc/dev/mysql-server/latest/classmysql_1_1binlog_1_1event_1_1Binary__log__event.html#packed_integer) ，也是变长，但具体规则不同。
1. `W`：一个字符最大占用的字节数，如 C1 字符集为 ascii，一个字符占用 1 字节，那么 W = 1
2. `M`: 表示 `VARCHAR(M)` 最多可存储 `M` 个字符，如 C1 VARCHAR(10)，那么 M = 10
3. `L`：实际存储的字符串的长度。如 C1 = 'aaaa'，那么 `L = 4 * W`

- 当字段的最大可能的长度 `W * M`（如C1：`10 * 1 = 10`）<= 255 时，只需要一个字节存储
- 当字段的最大可能的长度 > 255 时，需要两个字节存储
  - 如果 L <= 127，则用1个字节来表示真正字符串占用的字节数。
  - 如果 L > 127，则用2个字节来表示真正字符串占用的字节数。
- 当出现行溢出时，只存储留在本页面中的长度

#### NULL 值列表
**NULL 值列表的存储格式**
- bit 位图，每个 bit 代表一个字段是否为 NULL, 1 代表 NULL，0 代表非 NULL。
- 定义了 `not null` 的字段，不会记录。
- 逆序存放
- 必须是字节对齐的。不足一个字节的，高位用 0 补齐。

#### 记录头信息
记录头信息固定占用 5 Bytes

##### 记录字段说明

| 名称           | 大小（bit） | 描述                                                                         |
| :----------- | ------: | :------------------------------------------------------------------------- |
| 预留位1         |       1 | 没有使用                                                                       |
| 预留位2         |       1 | 没有使用                                                                       |
| delete_mask  |       1 | 标记该记录是否被删除                                                                 |
| min_rec_mask |       1 | B+树的每层非叶子节点中的最小记录都会添加该标记                                                   |
| n_owned      |       4 | 表示当前记录拥有的记录数。一个页面中的记录会分为若干组，**只有每一组的第一个记录才有值**，表示组中所有记录的条数，其他的 n_owned = 0 |
| heap_no      |      13 | 表示当前记录在记录堆的位置信息                                                            |
| record_type  |       3 | 当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录                      |
| next_record  |      16 | 表示下一条记录的相对位置                                                               |

#### 真实数据
MySQL 会将每一列的真实数据按照正序存放在记录头信息之后。除了我们定义的几列之外，还会有一些隐藏列，用于存储一些额外的信息。隐藏列在真正的数据列之前。

##### 隐藏列说明
| 名称           | 是否必须 | 大小（Byte） | 描述                     | 真实名称        |
| :----------- | :--: | -------: | :--------------------- | ----------- |
| row_id       |  否   |        6 | 行 ID，根据主键生成策略，有可能不需要生成 | DB_ROW_ID   |
| trx_id       |  是   |        6 | 事务 ID                  | DB_TRX_ID   |
| roll_pointer |  是   |        7 | 回滚指针                   | DB_ROLL_PTR |

主键生成策略：
1. 显示定义的主键
2. 选取一个不允许为 NULL 的 UNIQUE 键为主键，联合索引时每个字段都不允许为 NULL
3. 没有合适的键，InnoDB 会自动生成一个隐藏的主键 row_id

如果 1 2 两步可以找到主键，那么 这些列会被提前至 row_id 的地方，即 trx_id 前面。

##### 示例数据说明
[[002tech_notes/02MySQL/MySql是怎样运行的/04 InnoDB 行结构#record_format_demo 数据定义|示例数据]]
![[Excalidraw/InnoDB行结构.excalidraw#^group=jdmRMVhuAJIJOAI3IisFA|COMPACT 格式示例数据|1000]]

- ascii 字符集 'a'=0x61, 'b'=0x62 ....，空格=0x20。
- 第一行记录，C3 列为 `CHAR(10)`，不足 10 个字符，后面用空格填充。
- 第二行记录，C3、C4 列为 `NULL`，被存储在了 NULL 值列表中，真实数据中不再存储。

#### 溢出列
当某一列占用空间过大，导致整行记录无法存储在一个 page 中时，会将该列的部分数据存储在溢出页中，当一个溢出页无法存放所有数据时，溢出页会以链表的形式连接。
对于 COMPACT 和 REDUNDANT 行格式，会存储 768 字节的数据和 20 字节的溢出指针，如果超过 768 字节，会将剩余数据存储在溢出页中。

### DYNAMIC 行格式
MySQL 默认的格式。与 COMPACT 格式很像，只有溢出列的存储方式不同。
- COMPACT 格式中，溢出列的数据有 768 字节存储在记录中，剩余的存储在溢出页中。
- DYNAMIC 格式中，溢出列的数据都存储在溢出页中，记录中只存储 20 字节的溢出指针。

### COMPRESSED 行格式
相比 DYNAMIC 行格式，COMPRESSED 行格式会对数据进行压缩存储，减少存储空间。但是由于压缩算法的存在，会导致读取数据时需要解压，会增加 CPU 的消耗。

