## 1. 扩容机制
### 触发条件
- **元素数超阈值**：`sizeCtl = 容量 × 负载因子（默认0.75）`
- **链表转树检查**：链表长度>8且数组长度<64时优先扩容

### 多线程协作迁移
1. **初始化新数组**：容量翻倍，`sizeCtl`标记扩容状态
2. **任务分配**：
   - 通过`transferIndex`和`stride`（步长，默认最小16）分配迁移区间
   - 线程领取区间后从高位向低位迁移桶数据
3. **数据迁移**：
   - 链表按哈希高位拆分为`原位置`和`原位置+旧容量`两个链表
   - 红黑树拆分后根据长度决定是否退化为链表
4. **状态标记**：迁移完成的桶替换为`ForwardingNode`
5. **收尾替换**：所有迁移完成后替换旧数组

### 并发控制
- **写线程协助迁移**：`put`操作遇到`ForwardingNode`时调用`helpTransfer()`
- **读操作无锁**：遇到`ForwardingNode`直接跳转新数组查询

---

## 2. ForwardingNode 的作用
### 核心功能
- **占位标识**：哈希值固定为`MOVED(-1)`，标记桶已迁移
- **协调迁移**：触发其他线程协助迁移（`helpTransfer()`）
- **无缝查询**：读操作直接跳转新数组，写操作先协助迁移

### 特性
- 指向新数组引用`nextTable`
- 通过原子替换保证迁移状态可见性

---

## 3. 扩容期间的读操作（get）
### 执行流程
1. 计算哈希定位旧数组桶
2. 若桶未迁移：直接遍历链表/树
3. 若桶已迁移（`ForwardingNode`）：跳转新数组查询

### 设计保障
- **无锁化**：全程无锁，依赖`volatile`保证可见性
- **一致性**：通过`ForwardingNode`原子替换避免中间状态
- **高效性**：直接访问内存最新数据

---

## 4. Size 统计逻辑
### 分片计数设计
- **基础计数器**：`baseCount`（优先CAS更新）
- **分片计数器**：`CounterCell[]`（竞争激烈时启用）

### 计数流程
1. 插入/删除时调用`addCount()`
2. 优先更新`baseCount`，失败则更新分片计数器
3. 分片定位：通过线程探针值`ThreadLocalRandom.getProbe()`哈希到分片

### 特性
- **近似值**：`sumCount()`汇总`baseCount + 全部分片值`
- **低竞争优化**：分片扩容/探针重哈希分散竞争

---

## 5. 分片计数器定位机制
### 关键步骤
1. **生成探针值**：`ThreadLocalRandom.getProbe()`（线程本地随机数）
2. **计算索引**：`probe & (counterCells.length - 1)`
3. **竞争处理**：
   - CAS失败时生成新探针值（`advanceProbe()`）
   - 分片数组扩容（长度翻倍）

### 设计优势
- **无全局锁**：通过分片减少CAS竞争
- **动态适应**：根据竞争压力自动调整分片数

---

## 对比总结
| 特性                | ConcurrentHashMap          | HashMap         | Hashtable       |
|---------------------|----------------------------|-----------------|-----------------|
| **扩容期间读操作**   | 无锁跳转新数组              | 可能读到中间状态 | 全局锁阻塞       |
| **size()实现**      | 分片计数+近似值             | 直接返回字段值   | 同步锁保护       |
| **线程安全**        | 分段锁+CAS                 | 非线程安全       | 全局锁           |